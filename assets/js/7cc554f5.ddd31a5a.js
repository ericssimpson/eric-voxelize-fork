"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[7055],{1496:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>s,metadata:()=>i,toc:()=>d});var r=t(4246),o=t(1670);const s={sidebar_position:7},a="Voxelize Networking",i={id:"basics/handle-the-network",title:"Voxelize Networking",description:"In order to connect our frontend client to the backend Rust server, we need to create a network manager in Voxelize. The network manager handles all the ins and outs of the network packets. For example, the VOXELIZE.World requests for chunks on the server side, but you will need the network manager to send/receive these chunk data to and from the server.",source:"@site/docs/tutorials/basics/7-handle-the-network.md",sourceDirName:"basics",slug:"/basics/handle-the-network",permalink:"/tutorials/basics/handle-the-network",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"Create the Client",permalink:"/tutorials/basics/create-the-client"},next:{title:"Initialize the World",permalink:"/tutorials/basics/initialize-the-world"}},c={},d=[{value:"A Word on Network Intecepts",id:"a-word-on-network-intecepts",level:2},{value:"<code>onMessage</code>",id:"onmessage",level:3},{value:"<code>packets</code>",id:"packets",level:3},{value:"Connect to the Server",id:"connect-to-the-server",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.h1,{id:"voxelize-networking",children:"Voxelize Networking"}),"\n",(0,r.jsxs)(n.p,{children:["In order to connect our frontend client to the backend Rust server, we need to create a network manager in Voxelize. The network manager handles all the ins and outs of the network packets. For example, the ",(0,r.jsx)(n.code,{children:"VOXELIZE.World"})," requests for chunks on the server side, but you will need the network manager to send/receive these chunk data to and from the server."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",metastring:'title="main.js" ',children:"const network = new VOXELIZE.Network();\n\nnetwork.register(world);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"a-word-on-network-intecepts",children:"A Word on Network Intecepts"}),"\n",(0,r.jsx)(n.p,{children:"Such as the Voxelize world, network interceptors allow developers to peep into what network packets are received, and can also send packets out to the server."}),"\n",(0,r.jsx)(n.h3,{id:"onmessage",children:(0,r.jsx)(n.code,{children:"onMessage"})}),"\n",(0,r.jsxs)(n.p,{children:["The first thing you can implement for anything you ",(0,r.jsx)(n.code,{children:"register"})," onto the network is ",(0,r.jsx)(n.code,{children:"onMessage"}),". What ",(0,r.jsx)(n.code,{children:"onMessage"})," does is that when ",(0,r.jsx)(n.code,{children:"network.sync()"}),'  is called, the network "unpacks" all the network packets received in that frame, and passes those messages through each registered network interceptors. (',(0,r.jsx)(n.code,{children:"network.sync()"})," is called internally for you.)"]}),"\n",(0,r.jsx)(n.p,{children:"For example, say I want to print out all the message types whenever I receive any, I could simply do:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",children:"const myNetworkDebugger = {\n    onMessage(message) {\n        console.log(message.type);\n    }\n};\n\nnetwork.register(myNetworkDebugger);\n"})}),"\n",(0,r.jsxs)(n.p,{children:["Or, like what ",(0,r.jsx)(n.code,{children:"VOXELIZE.World"})," does ",(0,r.jsx)(n.a,{href:"https://github.com/shaoruu/voxelize/blob/b553674db761537d26ec6f6f5c2d75b341de377d/packages/core/src/core/world/index.ts#L1932-L1996",children:"here"}),", it listens to the ",(0,r.jsx)(n.code,{children:"INIT"}),", ",(0,r.jsx)(n.code,{children:"STATS"}),", ",(0,r.jsx)(n.code,{children:"LOAD"}),", and ",(0,r.jsx)(n.code,{children:"UPDATE"})," message types to handle chunking data and reflect any changes on the server (such as stats change to change the client's world time)."]}),"\n",(0,r.jsx)(n.h3,{id:"packets",children:(0,r.jsx)(n.code,{children:"packets"})}),"\n",(0,r.jsxs)(n.p,{children:["The other thing that developers can implement is a property, ",(0,r.jsx)(n.code,{children:"packets"}),", which is simply an array of network packets that will be emptied out and sent on ",(0,r.jsx)(n.code,{children:"network.flush()"}),", which is called for you internally just like ",(0,r.jsx)(n.code,{children:"network.sync()"}),"."]}),"\n",(0,r.jsx)(n.h2,{id:"connect-to-the-server",children:"Connect to the Server"}),"\n",(0,r.jsx)(n.p,{children:"Now we have a better understanding of the server, let's connect to the server and join our tutorial world."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-javascript",metastring:'title="main.js"',children:"function animate() {\n    requestAnimationFrame(animate);\n\n    renderer.render(world, camera);\n}\n\nasync function start() {\n    animate();\n\n    await network.connect('http://localhost:4000');\n    await network.join('tutorial');\n}\n\nstart();\n"})}),"\n",(0,r.jsx)(n.admonition,{type:"tip",children:(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"network.connect"})," automatically changes the protocol from anything (http here) to WebSockets (ws)."]})})]})}function h(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},1670:(e,n,t)=>{t.d(n,{Z:()=>i,a:()=>a});var r=t(7378);const o={},s=r.createContext(o);function a(e){const n=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),r.createElement(s.Provider,{value:n},e.children)}}}]);