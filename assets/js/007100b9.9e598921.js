"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9958],{5318:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>d});var a=n(7378);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},c=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),h=u(n),d=r,g=h["".concat(s,".").concat(d)]||h[d]||p[d]||i;return n?a.createElement(g,l(l({ref:t},c),{},{components:n})):a.createElement(g,l({ref:t},c))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=h;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var u=2;u<i;u++)l[u]=n[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9489:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>u});var a=n(5773),r=(n(7378),n(5318));const i={sidebar_position:5},l="Chunk Generation",o={unversionedId:"basics/chunk-generation",id:"basics/chunk-generation",title:"Chunk Generation",description:"In this chapter, we learn about how to populate blocks into empty chunks, in parallel.",source:"@site/docs/basics/5-chunk-generation.md",sourceDirName:"basics",slug:"/basics/chunk-generation",permalink:"/docs/basics/chunk-generation",draft:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/basics/5-chunk-generation.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"Create a World",permalink:"/docs/basics/create-a-world"},next:{title:"Protocol Networking",permalink:"/docs/basics/protocol-networking"}},s={},u=[{value:"Chunk Stage",id:"chunk-stage",level:2},{value:"The Chunk Pipeline",id:"the-chunk-pipeline",level:2},{value:"A Word on Chunk Stages",id:"a-word-on-chunk-stages",level:2},{value:"Resources of the World",id:"resources-of-the-world",level:3},{value:"<code>Space</code>\xa0Data Structure",id:"spacedata-structure",level:3},{value:"Progress Check",id:"progress-check",level:2}],c={toc:u};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"chunk-generation"},"Chunk Generation"),(0,r.kt)("p",null,"In this chapter, we learn about how to populate blocks into empty chunks, in parallel."),(0,r.kt)("h2",{id:"chunk-stage"},"Chunk Stage"),(0,r.kt)("p",null,"To populate chunks, developers define a list of chunk stages that each chunk has to go through. For example, there could be a\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"TreeStage"),"\xa0that places trees on each chunk, or there could be a\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"WaterStage"),"\xa0that fills water up to the sea level."),(0,r.kt)("p",null,"In this tutorial, we are going to define a\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"FlatlandStage"),", which simply populates the world with a flat land. (",(0,r.kt)("em",{parentName:"p"},"Hint: This stage actually comes built-in in Voxelize!"),")"),(0,r.kt)("p",null,"Let's set up the flat land stage first:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="server/main.rs"',title:'"server/main.rs"'},"// ...\npub struct FlatlandStage {\n    /// The height of the flat land.\n    height: i32,\n\n    /// Block type of the top of the flat land.\n    top: u32,\n\n    /// Block type of the middle of the flat land.\n    middle: u32,\n\n    /// Block type of the bottom of the flat land.\n    bottom: u32,\n}\n\nimpl FlatlandStage {\n    pub fn new(height: i32, top: u32, middle: u32, bottom: u32) -> Self {\n        Self {\n            height,\n            top,\n            middle,\n            bottom,\n        }\n    }\n}\n// ...\n")),(0,r.kt)("p",null,"Chunk stages all implement the\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"ChunkStage"),"\xa0trait, so let's do that next:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="server/main.rs"',title:'"server/main.rs"'},"use voxelize::{\n    Block, ChunkStage, Registry, ResourceResults, Server, Space, VoxelAccess, Voxelize, WorldConfig,\n};\n")),(0,r.kt)("admonition",{type:"note"},(0,r.kt)("ul",{parentName:"admonition"},(0,r.kt)("li",{parentName:"ul"},"The ",(0,r.kt)("inlineCode",{parentName:"li"},"VoxelAccess"),"\xa0trait allows developers to use chunk data access methods such as\xa0",(0,r.kt)("inlineCode",{parentName:"li"},"set_voxel")," on data structures like ",(0,r.kt)("inlineCode",{parentName:"li"},"Chunk")," or ",(0,r.kt)("inlineCode",{parentName:"li"},"Chunks"),"."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"Vec3"),"\xa0is a 3-number data structure used across Voxelize."))),(0,r.kt)("p",null,"Implement what the flat land stage does:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="server/main.rs"',title:'"server/main.rs"'},'// ...\nimpl ChunkStage for FlatlandStage {\n    fn name(&self) -> String {\n        "Flatland".to_owned()\n    }\n\n    fn process(&self, mut chunk: Chunk, _: ResourceResults, _: Option<Space>) -> Chunk {\n        // Minimum coordinates of the chunk.\n        let Vec3(min_x, _, min_z) = chunk.min;\n\n        // Maximum coordinates of the chunk.\n        let Vec3(max_x, _, max_z) = chunk.max;\n\n        // Loop through all voxels up to the defined height.\n        for vx in min_x..max_x {\n            for vz in min_z..max_z {\n                for vy in 0..self.height {\n                    // Set voxels conditionally.\n                    if vy == 0 {\n                        chunk.set_voxel(vx, vy, vz, self.bottom);\n                    } else if vy == self.height - 1 {\n                        chunk.set_voxel(vx, vy, vz, self.top);\n                    } else {\n                        chunk.set_voxel(vx, vy, vz, self.middle);\n                    }\n                }\n            }\n        }\n\n        // Return the chunk instance for it to progress to the next stage.\n        chunk\n    }\n}\n// ...\n')),(0,r.kt)("h2",{id:"the-chunk-pipeline"},"The Chunk Pipeline"),(0,r.kt)("p",null,"Now we have a chunk stage defined, it's time to add it to the world's pipeline. A chunk pipeline simply manages the multi-threading of the chunk populations, pipelining all the chunks requested through every stage."),(0,r.kt)("p",null,"We can access the world pipeline and add the stage to it:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="server/main.rs"',title:'"server/main.rs"'},'// ... Creating the world\n\n{\n    let registry = world.registry();\n\n    // Access the block ID\'s registered.\n    let dirt = registry.get_block_by_name("Dirt").id;\n    let stone = registry.get_block_by_name("Stone").id;\n\n    drop(registry);\n\n    let mut pipeline = world.pipeline_mut();\n\n    // Add a chunk stage with top block stone, middle dirt, and bottom stone.\n    pipeline.add_stage(FlatlandStage::new(10, stone, dirt, stone));\n}\n\n// ... Running the server\n')),(0,r.kt)("p",null,"The world should now be generating a flat land. In fact, you can simply import\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"FlatlandStage"),"\xa0from\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"voxelize::pipeline::FlatlandStage"),"!"),(0,r.kt)("p",null,":::TIP\nWe wrap the pipeline access with curly braces so that the pipeline lifetime is dropped after mutating.\n:::"),(0,r.kt)("h2",{id:"a-word-on-chunk-stages"},"A Word on Chunk Stages"),(0,r.kt)("p",null,"When working with chunk stages, developers may want to access more information about the world, such as the registry, chunks around that chunk, and the world configurations."),(0,r.kt)("h3",{id:"resources-of-the-world"},"Resources of the World"),(0,r.kt)("p",null,"By implementing the\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"stage.needs_resources"),"\xa0function, the stage would be presented with the configured data, including the registry, world config, seeded noise instance, and seeded terrain instance. You can then use these resources as such:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"// highlight-next-line\nuse voxelize::{ResourceRequirements, ResourceResults};\n\nimpl ChunkStage for MyStage {\n    // Define what resources you need, in this case the registry.\n    fn needs_resources(&self) -> ResourceRequirements {\n        // highlight-start\n        ResourceRequirements {\n            needs_registry: true,\n            ..Default::default()\n        }\n        // highlight-end\n    }\n\n    fn process(&self, chunk: Chunk, resources: ResourceResults, space: Option<Space>) -> Chunk {\n        // Use the resource in the process.\n        // highlight-next-line\n        let registry = resources.registry.unwrap();\n    }\n}\n")),(0,r.kt)("h3",{id:"spacedata-structure"},(0,r.kt)("a",{parentName:"h3",href:"https://github.com/shaoruu/voxelize/blob/master/server/world/voxels/space.rs"},(0,r.kt)("inlineCode",{parentName:"a"},"Space")),"\xa0Data Structure"),(0,r.kt)("p",null,"Voxelize achieves parallel chunk generation by utilizing a data structure called ",(0,r.kt)("inlineCode",{parentName:"p"},"Space"),". Essentially, spaces contain the data of a chunk along with the data of the surrounding chunks. Data includes voxels, lights, and height maps, all configurable."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"A space is provided to the stage if the\xa0",(0,r.kt)("inlineCode",{parentName:"li"},"stage.needs_space"),"\xa0function is implemented."),(0,r.kt)("li",{parentName:"ul"},"Spaces ensures that it contains chunks in stages equal to or greater than the center chunk."),(0,r.kt)("li",{parentName:"ul"},"Spaces can also be mutated, but they are deleted after each stage. So, use\xa0",(0,r.kt)("inlineCode",{parentName:"li"},"get_lights"),"\xa0or\xa0",(0,r.kt)("inlineCode",{parentName:"li"},"get_voxels"),"\xa0to get its individual chunk data.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"use voxelize::{Space, SpaceData};\n\nimpl ChunkStage for MyStage {\n    // Tell the pipeline that you need a space containing a margin of 2 blocks of light data.\n    fn needs_space() -> Option<SpaceData> {\n        // highlight-next-line\n        Some(SpaceData { needs_lights: true, ..Default::default() })    \n    }\n\n    fn process(&self, chunk: Chunk, resources: ResourceResults, space: Option<Space>) -> Chunk {\n        // You can then access neighboring chunk data.\n        // highlight-start\n        let space = space.unwrap();\n        space.get_sunlight(...)\n        // highlight-end\n    }\n}\n")),(0,r.kt)("h2",{id:"progress-check"},"Progress Check"),(0,r.kt)("p",null,"The code so far should look like this:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust",metastring:'title="server/main.rs"',title:'"server/main.rs"'},'// highlight-next-line\nuse voxelize::{Block, FlatlandStage, Registry, Server, Voxelize, World, WorldConfig};\n\n#[actix_web::main]\nasync fn main() -> std::io::Result<()> {\n    let mut registry = Registry::new();\n\n    let dirt = Block::new("Dirt").id(1).build();\n    let stone = Block::new("Stone").id(2).build();\n\n    registry.register_blocks(&[dirt, stone]);\n\n    let mut server = Server::new().port(4000).registry(&registry).build();\n\n    let config = WorldConfig::new()\n        .min_chunk([-1, -1])\n        .max_chunk([1, 1])\n        .build();\n\n    let mut world = World::new("example", &config);\n\n    // highlight-start\n    {\n        let registry = world.registry();\n\n        let dirt = registry.get_block_by_name("Dirt").id;\n        let stone = registry.get_block_by_name("Stone").id;\n\n        drop(registry);\n\n        let mut pipeline = world.pipeline_mut();\n        pipeline.add_stage(FlatlandStage::new(10, dirt, stone, stone));\n    }\n    // highlight-end\n\n    server.add_world(world).expect("Could not add world!");\n\n    Voxelize::run(server).await\n}\n')))}p.isMDXComponent=!0}}]);