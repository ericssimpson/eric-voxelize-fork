import {
  CanvasTexture,
  ClampToEdgeWrapping,
  Color,
  NearestFilter,
  SRGBColorSpace,
  Texture,
} from "three";
import { UV } from ".";
import { Face } from "./face";

export type AtlasDrawable =
  | typeof Image
  | HTMLImageElement
  | HTMLCanvasElement
  | Color
  | Texture;

/**
 * A texture atlas is a collection of textures that are packed into a single texture.
 * This is useful for reducing the number of draw calls required to render a scene, since
 * all block textures can be rendered with a single draw call.
 *
 * By default, the texture atlas creates an additional border around each texture to prevent
 * texture bleeding.
 *
 * ![Texture bleeding](/img/docs/texture-bleeding.png)
 *
 * @noInheritDoc
 */
export class AtlasTexture extends CanvasTexture {
  /**
   * The number of textures per side of the texture atlas
   */
  public countPerSide: number;

  /**
   * Since the texture atlas is a square, the dimension is the length of one side.
   */
  public dimension: number;

  /**
   * The canvas that is used to generate the texture this.
   */
  public canvas: HTMLCanvasElement;

  /**
   * The margin between each block texture in the this.
   */
  public atlasMargin = 0;

  /**
   * The offset of each block's texture to the end of its border.
   */
  public atlasOffset = 0;

  /**
   * The ratio of the texture on the atlas to the original texture.
   */
  public atlasRatio = 0;

  /**
   * The list of block animations that are being used by this texture atlas.
   */
  public animations: { animation: FaceAnimation; timer: any }[] = [];

  public faces: Face[] = [];

  /**
   * Create a new texture this.
   *
   * @param textureMap A map that points a side name to a texture or color.
   * @param ranges The ranges on the texture atlas generated by the server.
   * @param options The options used to create the texture this.
   * @returns The texture atlas generated.
   */
  constructor(
    countPerSide: number,
    dimension: number,
    faces: Face[] = [],
    canvas = document.createElement("canvas"),
  ) {
    super(canvas);

    this.canvas = canvas;

    this.countPerSide = countPerSide;
    this.dimension = dimension;
    this.faces = faces;

    if (countPerSide === 1) {
      this.atlasOffset = 0;
      this.atlasRatio = 1;
      this.atlasMargin = 0;
    } else {
      this.atlasOffset = 1 / (countPerSide * 4);

      this.atlasMargin = 1;
      this.atlasRatio =
        (this.atlasMargin / this.atlasOffset / countPerSide -
          2 * this.atlasMargin) /
        dimension;

      while (this.atlasRatio !== Math.floor(this.atlasRatio)) {
        this.atlasRatio *= 2;
        this.atlasMargin *= 2;
      }
    }

    const canvasWidth =
      (dimension * this.atlasRatio + this.atlasMargin * 2) * countPerSide;
    const canvasHeight =
      (dimension * this.atlasRatio + this.atlasMargin * 2) * countPerSide;
    this.canvas.width = canvasWidth;
    this.canvas.height = canvasHeight;

    const context = this.canvas.getContext("2d") as CanvasRenderingContext2D;
    context.imageSmoothingEnabled = false;

    this.makeCanvasPowerOfTwo(this.canvas);
    this.wrapS = ClampToEdgeWrapping;
    this.wrapT = ClampToEdgeWrapping;
    this.minFilter = NearestFilter;
    this.magFilter = NearestFilter;
    this.generateMipmaps = false;
    this.needsUpdate = true;
    this.colorSpace = SRGBColorSpace;

    const unknown = AtlasTexture.makeUnknownImage(canvasWidth / countPerSide);

    for (let x = 0; x < countPerSide; x++) {
      for (let y = 0; y < countPerSide; y++) {
        context.drawImage(
          unknown,
          (x / countPerSide) * canvasWidth,
          (y / countPerSide) * canvasHeight,
          canvasWidth / countPerSide,
          canvasHeight / countPerSide,
        );
      }
    }
  }

  static fromJSON(
    json: [string, Face[]][],
    options: Partial<{
      dimension: number;
    }> = {},
  ) {
    const { dimension = 32 } = options;

    const atlasMap = new Map<string, AtlasTexture>();

    for (const [id, faces] of json) {
      const independentFaces = faces.filter((face) => face.independent);

      if (independentFaces.length > 0) {
        for (const face of independentFaces) {
          const atlas = new AtlasTexture(1, dimension, [face]);

          atlas.drawImageToRange(
            face.range,
            AtlasTexture.makeUnknownImage(dimension),
          );

          atlas.needsUpdate = true;

          atlasMap.set(face.name, atlas);
        }

        continue;
      }

      const dependentFaces = faces.filter((face) => !face.independent);

      if (dependentFaces.length === 0) {
        continue;
      }

      let countPerSide = 1;
      const sqrt = Math.ceil(Math.sqrt(dependentFaces.length));
      while (countPerSide < sqrt) {
        countPerSide *= 2;
      }

      const atlas = new AtlasTexture(countPerSide, dimension, dependentFaces);

      for (const face of faces) {
        atlas.drawImageToRange(
          face.range,
          AtlasTexture.makeUnknownImage(dimension, face.name),
        );
      }

      atlas.needsUpdate = true;

      atlasMap.set(id, atlas);
    }

    return atlasMap;
  }

  drawImageToFace(
    faceName: string,
    image: AtlasDrawable,
    clearRect = true,
    opacity = 1.0,
  ) {
    const face = this.faces.find((face) => face.name === faceName);

    if (!face) {
      return;
    }

    this.drawImageToRange(face.range, image, clearRect, opacity);
  }

  /**
   * Draw a texture to a range on the texture atlas.
   *
   * @param range The range on the texture atlas to draw the texture to.
   * @param image The texture to draw to the range.
   */
  drawImageToRange(
    range: UV,
    image: AtlasDrawable,
    clearRect = true,
    opacity = 1.0,
  ) {
    const { startU, endV } = range;

    const image2 =
      image instanceof Texture
        ? image.image
        : (image as any as HTMLImageElement);

    if (!image2) {
      return;
    }

    const context = this.canvas.getContext("2d") as CanvasRenderingContext2D;

    context.save();

    const canvasWidth = this.canvas.width;
    const canvasHeight = this.canvas.height;

    context.globalAlpha = opacity;

    if (opacity !== 1) context.globalCompositeOperation = "lighter";

    if (clearRect) {
      context.clearRect(
        (startU - this.atlasOffset) * canvasWidth,
        (1 - endV - this.atlasOffset) * canvasHeight,
        this.dimension * this.atlasRatio + 2 * this.atlasMargin,
        this.dimension * this.atlasRatio + 2 * this.atlasMargin,
      );
    }

    if ((image as any as Color).isColor) {
      context.fillStyle = `#${(image as any).getHexString()}`;
      context.fillRect(
        (startU - this.atlasOffset) * canvasWidth,
        (1 - endV - this.atlasOffset) * canvasHeight,
        this.dimension * this.atlasRatio + 2 * this.atlasMargin,
        this.dimension * this.atlasRatio + 2 * this.atlasMargin,
      );

      return;
    }

    // Draw a background first.

    if (clearRect) {
      context.drawImage(
        image2,
        (startU - this.atlasOffset) * canvasWidth,
        (1 - endV - this.atlasOffset) * canvasHeight,
        this.dimension * this.atlasRatio + 2 * this.atlasMargin,
        this.dimension * this.atlasRatio + 2 * this.atlasMargin,
      );

      // Carve out the middle.
      context.clearRect(
        (startU - this.atlasOffset) * canvasWidth + this.atlasMargin,
        (1 - endV - this.atlasOffset) * canvasHeight + this.atlasMargin,
        this.dimension * this.atlasRatio,
        this.dimension * this.atlasRatio,
      );
    }

    // Draw the actual texture.
    context.drawImage(
      image2,
      (startU - this.atlasOffset) * canvasWidth + this.atlasMargin,
      (1 - endV - this.atlasOffset) * canvasHeight + this.atlasMargin,
      this.dimension * this.atlasRatio,
      this.dimension * this.atlasRatio,
    );

    context.restore();

    this.needsUpdate = true;
  }

  registerAnimation(
    range: UV,
    keyframes: [number, Color | HTMLImageElement][],
    fadeFrames = 0,
  ) {
    const animation = new FaceAnimation(range, keyframes, fadeFrames);

    const entry: { animation: FaceAnimation; timer: any } = {
      animation,
      timer: null,
    };

    const start = (index = 0) => {
      const keyframe = animation.keyframes[index];

      this.drawImageToRange(range, keyframe[1], this.countPerSide !== 1);

      entry.timer = setTimeout(() => {
        clearTimeout(entry.timer);

        const nextIndex = (index + 1) % animation.keyframes.length;

        if (fadeFrames > 0) {
          const nextKeyframe = animation.keyframes[nextIndex];

          const fade = (fraction = 0) => {
            if (fraction > fadeFrames) {
              start(nextIndex);
              return;
            }

            requestAnimationFrame(() => fade(fraction + 1));

            this.drawImageToRange(
              range,
              nextKeyframe[1],
              true,
              fraction / fadeFrames,
            );

            this.drawImageToRange(
              range,
              keyframe[1],
              false,
              1 - fraction / fadeFrames,
            );

            this.needsUpdate = true;
          };

          fade();
        } else {
          start(nextIndex);
        }

        this.needsUpdate = true;
      }, keyframe[0]);
    };

    this.animations.push(entry);

    start();
  }

  private makeCanvasPowerOfTwo(canvas?: HTMLCanvasElement | undefined) {
    let setCanvas = false;
    if (!canvas) {
      canvas = this.canvas;
      setCanvas = true;
    }
    const oldWidth = canvas.width;
    const oldHeight = canvas.height;
    const newWidth = Math.pow(2, Math.round(Math.log(oldWidth) / Math.log(2)));
    const newHeight = Math.pow(
      2,
      Math.round(Math.log(oldHeight) / Math.log(2)),
    );
    const newCanvas = document.createElement("canvas");
    newCanvas.width = newWidth;
    newCanvas.height = newHeight;
    newCanvas.getContext("2d")?.drawImage(canvas, 0, 0, newWidth, newHeight);
    if (setCanvas) {
      this.canvas = newCanvas;
    }
  }

  static makeUnknownImage(
    dimension: number,
    word: string = "?",
    color1 = "#0A2647",
    color2 = "#E1D7C6",
  ) {
    const canvas = document.createElement("canvas") as HTMLCanvasElement;
    const context = canvas.getContext("2d") as CanvasRenderingContext2D;

    context.imageSmoothingEnabled = false;
    context.canvas.width = dimension;
    context.canvas.height = dimension;

    context.fillStyle = color2;
    context.fillRect(0, 0, dimension, dimension);
    context.fillStyle = color1;
    context.textAlign = "center";
    context.textBaseline = "middle";
    context.fillText(word, dimension / 2, dimension / 2, dimension);

    return canvas;
  }

  static makeUnknownTexture(dimension: number) {
    const texture = new CanvasTexture(AtlasTexture.makeUnknownImage(dimension));

    texture.minFilter = NearestFilter;
    texture.magFilter = NearestFilter;
    texture.generateMipmaps = false;
    texture.needsUpdate = true;
    texture.colorSpace = SRGBColorSpace;

    return texture;
  }
}

/**
 * The animation data that is used internally in an atlas texture. This holds the data and will be used to draw on the texture atlas.
 */
export class FaceAnimation {
  /**
   * The range of the texture atlas that this animation uses.
   */
  public range: UV;

  /**
   * The keyframes of the animation. This will be queried and drawn to the
   * texture atlas.
   */
  public keyframes: [number, HTMLImageElement | Color][];

  /**
   * The fading duration between each keyframe in milliseconds.
   */
  public fadeFrames: number;

  /**
   * Create a new face animation. This holds the data and will be used to draw on the texture atlas.
   *
   * @param range The range of the texture atlas that this animation uses.
   * @param keyframes The keyframes of the animation. This will be queried and drawn to the texture atlas.
   * @param fadeFrames The fading duration between each keyframe in milliseconds.
   */
  constructor(
    range: UV,
    keyframes: [number, HTMLImageElement | Color][],
    fadeFrames = 0,
  ) {
    if (!range) {
      throw new Error("Texture range is required for FaceAnimation.");
    }

    if (keyframes.length <= 1) {
      throw new Error("FaceAnimation must have at least two keyframe.");
    }

    this.range = range;
    this.keyframes = keyframes as any;
    this.fadeFrames = fadeFrames;
  }
}
